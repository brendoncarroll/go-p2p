package natswarm

import (
	"context"
	"log"
	mrand "math/rand"
	"net"
	"sync"
	"time"

	"github.com/brendoncarroll/go-p2p"
	"github.com/syncthing/syncthing/lib/nat"
	"github.com/syncthing/syncthing/lib/upnp"
)

type service struct {
	ctx   context.Context
	cf    context.CancelFunc
	swarm p2p.Swarm

	mu     sync.Mutex
	tcpMap map[string]net.TCPAddr
	udpMap map[string]net.UDPAddr
}

func newService(swarm p2p.Swarm) *service {
	s := &service{
		swarm: swarm,
	}
	ctx := context.Background()
	s.ctx, s.cf = context.WithCancel(ctx)

	go s.run(ctx)
	return s
}

func (s *service) run(ctx context.Context) {
	natDevs := make(chan map[string]nat.Device)
	go s.discoverLoop(ctx, natDevs)
}

func (s *service) shutdown() {
	s.cf()
}

func (s *service) discoverLoop(ctx context.Context, dwn chan map[string]nat.Device) {
	defer close(dwn)
	timeout := 3 * time.Second

	ticker := time.NewTicker(time.Minute)
	defer ticker.Stop()

	natDevs := map[string]nat.Device{}
	for {
		natDevsNew := upnp.Discover(ctx, timeout, timeout)
		m := map[string]nat.Device{}
		for _, natDev := range natDevsNew {
			m[natDev.ID()] = natDev
		}
		if !sameKeys(natDevs, m) {
			log.Println("found new nat devices")
			natDevs = m
			dwn <- natDevs
		}

		select {
		case <-ticker.C:
		case <-s.ctx.Done():
			return
		}
	}
}

func (s *service) maintainMappingsLoop(ctx context.Context, ups chan map[string]nat.Device) {
	natDevs := make(map[string]nat.Device)

	for {
		select {
		case next := <-ups:
			for k, natDev := range next {
				if _, exists := natDevs[k]; !exists {
					if err := s.addMappings(natDev, 30*time.Second); err != nil {
						log.Println(err)
						continue
					}
				}
			}
		case <-ctx.Done():
			return
		}
	}
}

func (s *service) addMappings(natDev nat.Device, ttl time.Duration) error {
	const description = "go-p2p"

	natLocalIP := natDev.GetLocalIPAddress()
	for _, a := range s.swarm.LocalAddrs() {
		var (
			protocol     nat.Protocol
			internalPort int
			externalPort int = randomPort()
		)
		switch a := a.(type) {
		case p2p.HasTCP:
			tcpAddr := a.GetTCP()
			if !sameNetwork(tcpAddr.IP, natLocalIP) {
				continue
			}
			protocol = nat.TCP
			internalPort = tcpAddr.Port
		case p2p.HasUDP:
			udpAddr := a.GetUDP()
			if !sameNetwork(udpAddr.IP, natLocalIP) {
				continue
			}
			protocol = nat.TCP
			internalPort := udpAddr.Port
		default:
			continue
		}

		log.Println("adding mapping", protocol, internalPort, externalPort, ttl)
		port, err := natDev.AddPortMapping(protocol, internalPort, externalPort, description, ttl)
		if err != nil {
			return err
		}
		log.Println("added mapping", port)

		externalIP, err := natDev.GetExternalIPAddress()
		if err != nil {
			return err
		}

		s.mu.Lock()
		switch a := a.(type) {
		case p2p.HasTCP:
			tcpAddr := a.GetTCP()
			s.tcpMap[tcpAddr.String()] = net.TCPAddr{
				IP:   externalIP,
				Port: port,
			}
		case p2p.HasUDP:
			udpAddr := a.GetUDP()
			s.udpMap[udpAddr.String()] = net.UDPAddr{
				IP:   externalIP,
				Port: port,
			}
		}
		s.mu.Unlock()
	}
	return nil
}

func (s *service) mapAddr(x p2p.Addr) p2p.Addr {
	switch x1 := x.(type) {
	case p2p.HasTCP:
		tcpAddr := x1.GetTCP()
		s.mu.Lock()
		mappedAddr, exists := s.tcpMap[tcpAddr.String()]
		s.mu.Unlock()
		if !exists {
			return x
		}
		return x1.MapTCP(mappedAddr)

	case p2p.HasUDP:
		udpAddr := x1.GetUDP()
		s.mu.Lock()
		mappedAddr, exists := s.udpMap[udpAddr.String()]
		s.mu.Unlock()
		if !exists {
			return x
		}
		return x1.MapUDP(mappedAddr)
	default:
		return x
	}
}

func (s *service) mapAddrs(xs []p2p.Addr) []p2p.Addr {
	ys := []p2p.Addr{}
	for _, x := range xs {
		ys = append(ys, x)
		y := s.mapAddr(x)
		if y != x {
			ys = append(ys, y)
		}
	}
	return ys
}

func sameKeys(a, b map[string]nat.Device) bool {
	for k := range a {
		if _, exists := b[k]; !exists {
			return false
		}
	}
	for k := range b {
		if _, exists := a[k]; !exists {
			return false
		}
	}
	return true
}

func randomPort() int {
	maxPort := 1 << 16
	minPort := 10000
	return mrand.Intn(maxPort-minPort) + maxPort
}

func sameNetwork(a, b net.IP) bool {
	addrs, err := net.InterfaceAddrs()
	if err != nil {
		panic(err)
	}
	for _, addr := range addrs {
		ipNet := addr.(*net.IPNet)
		if ipNet.Contains(a) && ipNet.Contains(b) {
			return true
		}
	}
	return false
}
